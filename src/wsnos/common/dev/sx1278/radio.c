/**
 * @brief       : this
 * @file        : radio.c
 * @version     : v0.0.1
 * @author      : gang.cheng
 * @date        : 2016-01-14
 * change logs  :
 * Date       Version     Author        Note
 * 2016-01-14  v0.0.1  gang.cheng    first version
 */
#include "common/lib/lib.h"
#include "sys_arch/osel_arch.h"
#include "platform/platform.h"

#include "../radio_defs.h"

#include "radio.h"
DBG_THIS_MODULE("radio");
#define RSSI_OFFSET_LF                              -164
#define RSSI_OFFSET_HF                              -157

/*!
 * Radio registers definition
 */
typedef struct
{
    radio_modem_t modem;
    uint8_t       addr;
    uint8_t       value;
} radio_regs_t;

/*!
 * \brief Radio hardware registers initialization definition
 *
 * \remark Can be automatically generated by the SX1272 GUI (not yet implemented)
 */
#define RADIO_INIT_REGISTERS_VALUE                \
{                                                 \
    { MODEM_FSK , REG_LNA                , 0x23 },\
    { MODEM_FSK , REG_RXCONFIG           , 0x1E },\
    { MODEM_FSK , REG_RSSICONFIG         , 0xD2 },\
    { MODEM_FSK , REG_PREAMBLEDETECT     , 0xAA },\
    { MODEM_FSK , REG_OSC                , 0x07 },\
    { MODEM_FSK , REG_SYNCCONFIG         , 0x12 },\
    { MODEM_FSK , REG_SYNCVALUE1         , 0xC1 },\
    { MODEM_FSK , REG_SYNCVALUE2         , 0x94 },\
    { MODEM_FSK , REG_SYNCVALUE3         , 0xC1 },\
    { MODEM_FSK , REG_PACKETCONFIG1      , 0xD8 },\
    { MODEM_FSK , REG_FIFOTHRESH         , 0x8F },\
    { MODEM_FSK , REG_IMAGECAL           , 0x02 },\
    { MODEM_FSK , REG_DIOMAPPING1        , 0x00 },\
    { MODEM_FSK , REG_DIOMAPPING2        , 0x30 },\
    { MODEM_LORA, REG_LR_PAYLOADMAXLENGTH, 0x40 },\
}

dio_irq_handler *dio_irq[] = {  sx127x_dio0_irq, sx127x_dio1_irq,
                                sx127x_dio2_irq, sx127x_dio3_irq,
                                sx127x_dio4_irq, NULL
                             };

const radio_regs_t radio_regs_init[] = RADIO_INIT_REGISTERS_VALUE;

radio_settings_t sx127x;
static uint8_t op_mode_prev = RF_OPMODE_STANDBY;
static rf_int_reg_t rf_int_reg[RF_INT_MAX_NUM];
static bool_t volatile cad_done = FALSE;        //*< CAD中断产生
static bool_t volatile cad_detected = FALSE;    //*< CAD检测到同步字
static uint32_t basic_feq = RF_FREQUENCY;
static uint32_t rf_channel_offset = 0;

void sx127x_write_buffer(uint8_t addr, uint8_t *buf, uint8_t size)
{
    SX127X_SPI_BEGIN();

    sx127x_spi_write_read(addr | FIFO_WRITE_MASK);

    for (uint8_t i = 0; i < size; i++)
    {
        sx127x_spi_write_read(buf[i]);
    }

    SX127X_SPI_END();
}

void sx127x_read_buffer(uint8_t addr, uint8_t *buf, uint8_t size)
{
    SX127X_SPI_BEGIN();

    sx127x_spi_write_read(addr & FIFO_READ_MASK);

    for (uint8_t i = 0; i < size; i++)
    {
        buf[i] = sx127x_spi_write_read(0xFF);
    }

    SX127X_SPI_END();
}

void sx127x_write_reg(uint8_t addr, uint8_t data)
{
    sx127x_write_buffer(addr, &data, 1);
}

uint8_t sx127x_read_reg(uint8_t addr)
{
    uint8_t data;
    sx127x_read_buffer(addr, &data, 1);

    return data;
}

static void sx127x_set_channel(uint32_t freq)
{
    sx127x.freq = freq;
    freq = (uint32_t)((fp32_t)freq / (fp32_t)FREQ_STEP);

    sx127x_write_reg( REG_FRFMSB, ( uint8_t )( ( freq >> 16 ) & 0xFF ) );
    sx127x_write_reg( REG_FRFMID, ( uint8_t )( ( freq >> 8 ) & 0xFF ) );
    sx127x_write_reg( REG_FRFLSB, ( uint8_t )( freq & 0xFF ) );
}

static uint8_t sx127x_get_pa_select(uint32_t freq)
{
    if ( freq > RF_MID_BAND_THRESH )
    {
        return RF_PACONFIG_PASELECT_PABOOST;
    }
    else
    {
//        return RF_PACONFIG_PASELECT_RFO;
        return RF_PACONFIG_PASELECT_PABOOST;
    }
}

static void sx127x_set_ant_sw_lowpower(bool_t status)
{
    static bool_t radio_is_active = FALSE;
    if (radio_is_active != status)
    {
        radio_is_active = status;

        if (status == FALSE)
        {
            sx127x_ant_sw_init();
        }
        else
        {
            sx127x_ant_sw_deinit();
        }
    }
}


void sx127x_set_op_mode(uint8_t op_mode)
{
    sx127x_read_reg( REG_OPMODE );

    if (op_mode != op_mode_prev)
    {
        op_mode_prev = op_mode;
        if (op_mode == RF_OPMODE_SLEEP)
        {
            sx127x_set_ant_sw_lowpower(TRUE);
        }
        else
        {
            sx127x_set_ant_sw_lowpower(FALSE);
            if (op_mode == RF_OPMODE_TRANSMITTER)
            {
                sx127x_ant_sw_set(1);
            }
            else
            {
                sx127x_ant_sw_set(0);
            }
        }

        sx127x_write_reg( REG_OPMODE,
                          ( sx127x_read_reg( REG_OPMODE ) & RF_OPMODE_MASK ) | op_mode );
    }
}

static void sx127x_set_modem(radio_modem_t modem)
{
    if (sx127x.modem == modem)
    {
        return;
    }

    sx127x.modem = modem;
    sx127x_set_op_mode(RF_OPMODE_SLEEP);
    sx127x.state = RF_SLEEP_STATE;
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        sx127x_write_reg( REG_OPMODE, ((sx127x_read_reg( REG_OPMODE ) &
                                        RFLR_OPMODE_LONGRANGEMODE_MASK ) |
                                       RFLR_OPMODE_LONGRANGEMODE_OFF) );

        sx127x_write_reg( REG_DIOMAPPING1, 0x00 );
        sx127x_write_reg( REG_DIOMAPPING2, 0x30 ); // DIO5=ModeReady
        break;

    case MODEM_LORA:
        sx127x_write_reg( REG_LR_OPMODE, (( sx127x_read_reg( REG_OPMODE ) &
                                            RFLR_OPMODE_LONGRANGEMODE_MASK ) |
                                          RFLR_OPMODE_LONGRANGEMODE_ON ));

        sx127x_write_reg( REG_DIOMAPPING1, 0x00 );
        sx127x_write_reg( REG_DIOMAPPING2, 0x00 );
        break;
    }
}

static void sx127x_set_datarate(int8_t datarate)
{
    if ( datarate > 12 )
    {
        datarate = 12;
    }
    else if ( datarate < 6 )
    {
        datarate = 6;
    }
    sx127x.lora.datarate = datarate;
    
    sx127x_write_reg( REG_LR_MODEMCONFIG2,
                  ( sx127x_read_reg( REG_LR_MODEMCONFIG2 ) &
                    RFLR_MODEMCONFIG2_SF_MASK &
                    RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK ) |
                  ( datarate << 4 ) | ( sx127x.lora.crc_on << 2 ) );
    sx127x_write_reg( REG_LR_MODEMCONFIG3,
                  ( sx127x_read_reg( REG_LR_MODEMCONFIG3 ) &
                    RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
                  ( sx127x.lora.low_datarate_optimize << 3 ) );
        
    if ( datarate == 6 )
    {
        sx127x_write_reg( REG_LR_DETECTOPTIMIZE,
                          ( sx127x_read_reg( REG_LR_DETECTOPTIMIZE ) &
                            RFLR_DETECTIONOPTIMIZE_MASK ) |
                          RFLR_DETECTIONOPTIMIZE_SF6 );
        sx127x_write_reg( REG_LR_DETECTIONTHRESHOLD,
                          RFLR_DETECTIONTHRESH_SF6 );
    }
    else
    {
        sx127x_write_reg( REG_LR_DETECTOPTIMIZE,
                          ( sx127x_read_reg( REG_LR_DETECTOPTIMIZE ) &
                            RFLR_DETECTIONOPTIMIZE_MASK ) |
                          RFLR_DETECTIONOPTIMIZE_SF7_TO_SF12 );
        sx127x_write_reg( REG_LR_DETECTIONTHRESHOLD,
                          RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
    }
}

static void sx127x_set_power(int8_t power)
{
    sx127x.lora.power = power;
    uint8_t pa_config = sx127x_read_reg( REG_PACONFIG );
    uint8_t paDac = sx127x_read_reg( REG_PADAC );

    pa_config = ( pa_config & RF_PACONFIG_PASELECT_MASK ) |
                sx127x_get_pa_select( (uint32_t)sx127x.freq );
    pa_config = ( pa_config & RF_PACONFIG_MAX_POWER_MASK ) | 0x70;

    if ( ( pa_config & RF_PACONFIG_PASELECT_PABOOST ) == RF_PACONFIG_PASELECT_PABOOST )
    {
        if ( power > 17 )
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_ON;
        }
        else
        {
            paDac = ( paDac & RF_PADAC_20DBM_MASK ) | RF_PADAC_20DBM_OFF;
        }
        if ( ( paDac & RF_PADAC_20DBM_ON ) == RF_PADAC_20DBM_ON )
        {
            if ( power < 5 )
            {
                power = 5;
            }
            if ( power > 20 )
            {
                power = 20;
            }
            pa_config = (pa_config & RF_PACONFIG_OUTPUTPOWER_MASK) |
                        (uint8_t)((uint16_t)(power - 5) & 0x0F );
        }
        else
        {
            if ( power < 2 )
            {
                power = 2;
            }
            if ( power > 17 )
            {
                power = 17;
            }
            pa_config = (pa_config & RF_PACONFIG_OUTPUTPOWER_MASK) |
                        (uint8_t)((uint16_t)(power - 2) & 0x0F );
        }
    }
    else
    {
        if ( power < -1 )
        {
            power = -1;
        }
        if ( power > 14 )
        {
            power = 14;
        }
        pa_config = ( pa_config & RF_PACONFIG_OUTPUTPOWER_MASK )
                    | ( uint8_t )( ( uint16_t )( power + 1 ) & 0x0F );
    }
    sx127x_write_reg( REG_PACONFIG, pa_config );
    sx127x_write_reg( REG_PADAC, paDac );
}

//static void sx127x_set_freq_offset(uint32_t value)
//{
//    //@todo fsk only
//}

/**
 * [sx127x_set_preamble description]
 * \param [IN] preambleLen  Sets the preamble length
 *      FSK : Number of bytes
 *      LoRa: Length in symbols (the hardware adds 4 more symbols)
 */
static void sx127x_set_preamble(uint8_t preambleLen)
{
    sx127x.lora.preamble_len = preambleLen;
    if (sx127x.modem == MODEM_FSK)
    {
        sx127x_write_reg( REG_PREAMBLEMSB, ( preambleLen >> 8 ) & 0x00FF );
        sx127x_write_reg( REG_PREAMBLELSB, preambleLen & 0xFF );
    }
    else
    {
        sx127x_write_reg( REG_LR_PREAMBLEMSB, ( preambleLen >> 8 ) & 0x00FF );
        sx127x_write_reg( REG_LR_PREAMBLELSB, preambleLen & 0xFF );
    }
}

/**
 * [sx127x_set_rxtimeout description]
 * @param value timeout = value * Ts
 */
static void sx127x_set_rxtimeout(uint16_t value)
{
    sx127x_write_reg( REG_LR_MODEMCONFIG2,
                      ( sx127x_read_reg( REG_LR_MODEMCONFIG2 ) &
                        RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK ) |
                      ((value >> 8) & ~RFLR_MODEMCONFIG2_SYMBTIMEOUTMSB_MASK));

    sx127x_write_reg( REG_LR_SYMBTIMEOUTLSB, (uint8_t)(value & 0xFF));
}

/**
 * [sx127x_set_fix description]
 * @param fix_en      [Fixed length packets [0: variable, 1: fixed]]
 * @param payload_len
 */
void sx127x_set_fix(uint8_t fix_len, uint8_t payload_len)
{
    sx127x.lora.fix_len  = fix_len;
    sx127x_write_reg( REG_LR_MODEMCONFIG1,
                      ( sx127x_read_reg( REG_LR_MODEMCONFIG1 ) &
                        RFLR_MODEMCONFIG1_IMPLICITHEADER_MASK ) | fix_len );

    if (fix_len == 1)
    {
        sx127x_write_reg( REG_LR_PAYLOADLENGTH, payload_len );
    }
}

void sx127x_set_iqinverted(bool_t iq_inverted)
{
    sx127x.lora.iq_inverted = iq_inverted;

    if (sx127x.lora.iq_inverted == TRUE)
    {
        sx127x_write_reg(REG_LR_INVERTIQ, ((sx127x_read_reg(REG_LR_INVERTIQ) &
                                            RFLR_INVERTIQ_TX_MASK &
                                            RFLR_INVERTIQ_RX_MASK ) |
                                           RFLR_INVERTIQ_RX_OFF |
                                           RFLR_INVERTIQ_TX_ON));
        sx127x_write_reg(REG_LR_INVERTIQ2, RFLR_INVERTIQ2_ON);
    }
    else
    {
        sx127x_write_reg(REG_LR_INVERTIQ, ((sx127x_read_reg(REG_LR_INVERTIQ) &
                                            RFLR_INVERTIQ_TX_MASK &
                                            RFLR_INVERTIQ_RX_MASK ) |
                                           RFLR_INVERTIQ_RX_OFF |
                                           RFLR_INVERTIQ_TX_OFF));
        sx127x_write_reg(REG_LR_INVERTIQ2, RFLR_INVERTIQ2_OFF);
    }
}

/**
 * [sx127x_set_bandwidth description]
 * @param [in] bandwidth
 *  - 0 7.8k
 *  - 1 10.4k
 *  - 2 15.6k
 *  - 3 20.8k
 *  - 4 31.25k
 *  - 5 41.7k
 *  - 6 62.5k
 *  - 7 125k
 *  - 8 250k
 *  - 9 500k
 *  @param [in] datarate  Sets the Datarate
 *      FSK : 600..300000 bits/s
 *      LoRa: [6: 64, 7: 128, 8: 256, 9: 512,
 *             10: 1024, 11: 2048, 12: 4096  chips]
 *  @param [in] coderate Sets the coding rate (LoRa only)
 *      FSK : N/A ( set to 0 )
 *      LoRa: [1: 4/5, 2: 4/6, 3: 4/7, 4: 4/8]
 *  @param [in] crcOn        Enables disables the CRC [0: OFF, 1: ON]
 */
static void sx127x_set_config(uint8_t bandwidth,
                              uint32_t datarate,
                              uint8_t coderate,
                              uint8_t crc_on)
{
    if (sx127x.modem == MODEM_FSK)
    {
        //@todo
        return;
    }
    else
    {
        sx127x.lora.bandwidth = bandwidth;
        sx127x.lora.datarate  = datarate;
        sx127x.lora.coderate  = coderate;

        if ( datarate > 12 )
        {
            datarate = 12;
        }
        else if ( datarate < 6 )
        {
            datarate = 6;
        }
        if ( ( ( bandwidth == 7 ) && ( ( datarate == 11 ) || ( datarate == 12 ) ) ) ||
                ( ( bandwidth == 8 ) && ( datarate == 12 ) ) )
        {
            sx127x.lora.low_datarate_optimize = TRUE;
        }
        else
        {
            sx127x.lora.low_datarate_optimize = FALSE;
        }

        sx127x_write_reg( REG_LR_MODEMCONFIG1,
                          ( sx127x_read_reg( REG_LR_MODEMCONFIG1 ) &
                            RFLR_MODEMCONFIG1_BW_MASK &
                            RFLR_MODEMCONFIG1_CODINGRATE_MASK) |
                          ( bandwidth << 4 ) | ( coderate << 1 ) );

        sx127x_write_reg( REG_LR_MODEMCONFIG2,
                          ( sx127x_read_reg( REG_LR_MODEMCONFIG2 ) &
                            RFLR_MODEMCONFIG2_SF_MASK &
                            RFLR_MODEMCONFIG2_RXPAYLOADCRC_MASK ) |
                          ( datarate << 4 ) | ( crc_on << 2 ) );
        sx127x.lora.crc_on = crc_on;
        sx127x_write_reg( REG_LR_MODEMCONFIG3,
                          ( sx127x_read_reg( REG_LR_MODEMCONFIG3 ) &
                            RFLR_MODEMCONFIG3_LOWDATARATEOPTIMIZE_MASK ) |
                          ( sx127x.lora.low_datarate_optimize << 3 ) );

        if ( ( bandwidth == 9 ) && ( RF_MID_BAND_THRESH ) )
        {
            // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
            sx127x_write_reg( REG_LR_TEST36, 0x02 );
            sx127x_write_reg( REG_LR_TEST3A, 0x64 );
        }
        else if ( bandwidth == 9 )
        {
            // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
            sx127x_write_reg( REG_LR_TEST36, 0x02 );
            sx127x_write_reg( REG_LR_TEST3A, 0x7F );
        }
        else
        {
            // ERRATA 2.1 - Sensitivity Optimization with a 500 kHz Bandwidth
            sx127x_write_reg( REG_LR_TEST36, 0x03 );
        }

        if ( datarate == 6 )
        {
            sx127x_write_reg( REG_LR_DETECTOPTIMIZE,
                              ( sx127x_read_reg( REG_LR_DETECTOPTIMIZE ) &
                                RFLR_DETECTIONOPTIMIZE_MASK ) |
                              RFLR_DETECTIONOPTIMIZE_SF6 );
            sx127x_write_reg( REG_LR_DETECTIONTHRESHOLD,
                              RFLR_DETECTIONTHRESH_SF6 );
        }
        else
        {
            sx127x_write_reg( REG_LR_DETECTOPTIMIZE,
                              ( sx127x_read_reg( REG_LR_DETECTOPTIMIZE ) &
                                RFLR_DETECTIONOPTIMIZE_MASK ) |
                              RFLR_DETECTIONOPTIMIZE_SF7_TO_SF12 );
            sx127x_write_reg( REG_LR_DETECTIONTHRESHOLD,
                              RFLR_DETECTIONTHRESH_SF7_TO_SF12 );
        }
    }
}

static void sx127x_set_hopping(bool_t freq_hop_on,
                               uint8_t hop_period)
{

    if (sx127x.modem == MODEM_FSK)
    {
        DBG_ASSERT(FALSE __DBG_LINE);
    }

    sx127x.lora.freq_hop_on = freq_hop_on;
    sx127x.lora.hop_period  = hop_period;

    if (freq_hop_on == TRUE )
    {
        sx127x_write_reg( REG_LR_PLLHOP,  ((sx127x_read_reg( REG_LR_PLLHOP ) &
                                            RFLR_PLLHOP_FASTHOP_MASK ) |
                                           RFLR_PLLHOP_FASTHOP_ON));
        sx127x_write_reg( REG_LR_HOPPERIOD, hop_period);
    }
}

static void rx_chain_calibration(void)
{
    uint8_t reg_paconfig_initval = sx127x_read_reg(REG_PACONFIG);
    //*< 434Mhz
    fp32_t temp_freq = (double)(((uint32_t)sx127x_read_reg(REG_FRFMSB) << 16) |
                                ((uint32_t)sx127x_read_reg(REG_FRFMID) << 8) |
                                ((uint32_t)sx127x_read_reg(REG_FRFLSB)))
                       * ( double )FREQ_STEP;

    // Cut the PA just in case, RFO output, power = -1 dBm
    sx127x_write_reg( REG_PACONFIG, 0x00 );

    sx127x_write_reg( REG_IMAGECAL, (( sx127x_read_reg( REG_IMAGECAL )
                                       & RF_IMAGECAL_IMAGECAL_MASK ) |
                                     RF_IMAGECAL_IMAGECAL_START ));
    while ( ( sx127x_read_reg( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_RUNNING )
            == RF_IMAGECAL_IMAGECAL_RUNNING )
    {
    }

// set a frequency in HF band
    sx127x_set_channel(868000000);

// Launch Rx chain calibration for HF band
    sx127x_write_reg( REG_IMAGECAL, (( sx127x_read_reg( REG_IMAGECAL )
                                       & RF_IMAGECAL_IMAGECAL_MASK ) |
                                     RF_IMAGECAL_IMAGECAL_START ));
    while ( ( sx127x_read_reg( REG_IMAGECAL ) & RF_IMAGECAL_IMAGECAL_RUNNING )
            == RF_IMAGECAL_IMAGECAL_RUNNING )
    {
    }

// restore context
    sx127x_write_reg(REG_PACONFIG, reg_paconfig_initval);
    sx127x_set_channel((uint32_t)temp_freq);
}

int16_t sx127x_get_rssi(void)
{
    int16_t rssi_val = 0;
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        //sx127x.fsk_packet.rssi_value = -( sx127x_read_reg( REG_RSSIVALUE ) >> 1 );
        //rssi_val = sx127x.fsk_packet.rssi_value;
        break;

    case MODEM_LORA:
    {
        int8_t snr = 0;
        sx127x.lora_packet.snr_value = sx127x_read_reg( REG_LR_PKTSNRVALUE );
        if ( sx127x.lora_packet.snr_value & 0x80 ) // The SNR sign bit is 1
        {
            // Invert and divide by 4
            snr = ( ( ~sx127x.lora_packet.snr_value + 1 ) & 0xFF ) >> 2;
            snr = -snr;
        }
        else
        {
            // Divide by 4
            snr = ( sx127x.lora_packet.snr_value & 0xFF ) >> 2;
        }

        int16_t rssi = sx127x_read_reg( REG_LR_PKTRSSIVALUE );
        if ( snr < 0 )
        {
            if ( sx127x.freq > RF_MID_BAND_THRESH )
            {
                sx127x.lora_packet.rssi_value = RSSI_OFFSET_HF + rssi + ( rssi >> 4 ) +
                                                snr;
            }
            else
            {
                sx127x.lora_packet.rssi_value = RSSI_OFFSET_LF + rssi + ( rssi >> 4 ) +
                                                snr;
            }
        }
        else
        {
            if ( sx127x.freq > RF_MID_BAND_THRESH )
            {
                sx127x.lora_packet.rssi_value = RSSI_OFFSET_HF + rssi + ( rssi >> 4 );
            }
            else
            {
                sx127x.lora_packet.rssi_value = RSSI_OFFSET_LF + rssi + ( rssi >> 4 );
            }
        }

        rssi_val = sx127x.lora_packet.rssi_value;
    }
    break;

    default:
        break;
    }

    return rssi_val;
}

bool_t sx127x_enter_sleep(void)
{
    if (sx127x.state == RF_SLEEP_STATE)
    {
        return FALSE;
    }

    sx127x.state = RF_SLEEP_STATE;

    sx127x_set_op_mode( RF_OPMODE_SLEEP );
    return TRUE;
}

bool_t sx127x_enter_idle(void)
{
    if (sx127x.state == RF_IDLE_STATE)
    {
        return FALSE;
    }

    sx127x.state = RF_IDLE_STATE;
    sx127x_set_op_mode(RF_OPMODE_STANDBY);
    return TRUE;
}

bool_t sx127x_enter_tx(void)
{
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        break;

    case MODEM_LORA:
    {
        if ( sx127x.lora.freq_hop_on == TRUE )
        {
            sx127x_write_reg( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
                              RFLR_IRQFLAGS_RXDONE |
                              RFLR_IRQFLAGS_PAYLOADCRCERROR |
                              RFLR_IRQFLAGS_VALIDHEADER |
                              RFLR_IRQFLAGS_CADDONE |
                              RFLR_IRQFLAGS_CADDETECTED );

            // DIO0=TxDone, DIO2=FhssChangeChannel
            sx127x_write_reg(REG_DIOMAPPING1, (sx127x_read_reg(REG_DIOMAPPING1)&
                                               RFLR_DIOMAPPING1_DIO0_MASK &
                                               RFLR_DIOMAPPING1_DIO2_MASK ) |
                             RFLR_DIOMAPPING1_DIO0_01 | RFLR_DIOMAPPING1_DIO2_00);
        }
        else
        {
            sx127x_write_reg( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
                              RFLR_IRQFLAGS_RXDONE |
                              RFLR_IRQFLAGS_PAYLOADCRCERROR |
                              RFLR_IRQFLAGS_VALIDHEADER |
                              // RFLR_IRQFLAGS_TXDONE |
                              RFLR_IRQFLAGS_CADDONE |
                              RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                              RFLR_IRQFLAGS_CADDETECTED );

            // DIO0=TxDone
            sx127x_write_reg(REG_DIOMAPPING1, (sx127x_read_reg(REG_DIOMAPPING1)&
                                               RFLR_DIOMAPPING1_DIO0_MASK ) |
                             RFLR_DIOMAPPING1_DIO0_01 );
        }
    }
    break;

    default:
        DBG_ASSERT(FALSE __DBG_LINE);
        break;
    }

    sx127x.state = RF_TX_STATE;
    sx127x_set_op_mode(RF_OPMODE_TRANSMITTER | RF_OPMODE_LFMODE);
    return TRUE;
}

bool_t sx127x_enter_rx(void)
{
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        break;

    case MODEM_LORA:
    {
        sx127x_set_iqinverted(sx127x.lora.iq_inverted);

        if (sx127x.lora.bandwidth < 9)
        {
            sx127x_write_reg( REG_LR_DETECTOPTIMIZE,
                              sx127x_read_reg( REG_LR_DETECTOPTIMIZE ) & 0x7F );
            sx127x_write_reg( REG_LR_TEST30, 0x00 );
            switch (sx127x.lora.bandwidth)
            {
            case 0: // 7.8 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x48 );
                sx127x_set_channel((uint32_t)(sx127x.freq + 7.81e3 ));
                break;
            case 1: // 10.4 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x44 );
                sx127x_set_channel((uint32_t)(sx127x.freq + 10.42e3 ));
                break;
            case 2: // 15.6 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x44 );
                sx127x_set_channel((uint32_t)(sx127x.freq + 15.62e3 ));
                break;
            case 3: // 20.8 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x44 );
                sx127x_set_channel((uint32_t)(sx127x.freq + 20.83e3 ));
                break;
            case 4: // 31.2 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x44 );
                sx127x_set_channel((uint32_t)(sx127x.freq + 31.25e3 ));
                break;
            case 5: // 41.4 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x44 );
                sx127x_set_channel((uint32_t)(sx127x.freq + 41.67e3 ));
                break;
            case 6: // 62.5 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x40 );
                break;
            case 7: // 125 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x40 );
                break;
            case 8: // 250 kHz
                sx127x_write_reg( REG_LR_TEST2F, 0x40 );
                break;
            }
        }
        else            // 500khz
        {
            sx127x_write_reg( REG_LR_DETECTOPTIMIZE,
                              sx127x_read_reg( REG_LR_DETECTOPTIMIZE ) | 0x80 );
        }

        if ( sx127x.lora.freq_hop_on == TRUE )
        {
            sx127x_write_reg( REG_LR_IRQFLAGSMASK, (RFLR_IRQFLAGS_VALIDHEADER |
                                                    RFLR_IRQFLAGS_TXDONE |
                                                    RFLR_IRQFLAGS_CADDONE |
                                                    RFLR_IRQFLAGS_CADDETECTED) );
            // DIO0=RxDone, DIO2=FhssChangeChannel
            sx127x_write_reg(REG_DIOMAPPING1, (sx127x_read_reg(REG_DIOMAPPING1)&
                                               RFLR_DIOMAPPING1_DIO0_MASK &
                                               RFLR_DIOMAPPING1_DIO2_MASK  ) |
                             RFLR_DIOMAPPING1_DIO0_00 | RFLR_DIOMAPPING1_DIO2_00);
        }
        else
        {
            sx127x_write_reg( REG_LR_IRQFLAGSMASK, (
//                                                    RFLR_IRQFLAGS_VALIDHEADER |
                                  RFLR_IRQFLAGS_TXDONE |
                                  RFLR_IRQFLAGS_CADDONE |
                                  RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL |
                                  RFLR_IRQFLAGS_CADDETECTED) );
            // DIO0=RxDone
            sx127x_write_reg(REG_DIOMAPPING1, (sx127x_read_reg(REG_DIOMAPPING1)&
                                               RFLR_DIOMAPPING1_DIO0_MASK )
                             | RFLR_DIOMAPPING1_DIO0_00 );
        }
        uint8_t temp = sx127x_read_reg(REG_LR_IRQFLAGSMASK);
        temp = sx127x_read_reg(REG_LR_MODEMCONFIG2);
        temp = sx127x_read_reg(REG_LR_SYMBTIMEOUTLSB);
        temp = temp;
        sx127x_write_reg(REG_DIOMAPPING1, (sx127x_read_reg(REG_DIOMAPPING1)&
                                           RFLR_DIOMAPPING1_DIO3_MASK )
                         | RFLR_DIOMAPPING1_DIO3_01 );

        sx127x_write_reg( REG_LR_FIFORXBASEADDR, 0 );
        sx127x_write_reg( REG_LR_FIFOADDRPTR, 0 );

        sx127x.state = RF_RX_STATE;
        if ( sx127x.lora.rx_continuous == TRUE )
        {
            sx127x_set_op_mode( RFLR_OPMODE_RECEIVER );
        }
        else
        {
            sx127x_set_op_mode( RFLR_OPMODE_RECEIVER_SINGLE );
        }

    }
    break;

    default:
        DBG_ASSERT(FALSE __DBG_LINE);
        break;
    }
    return TRUE;
}

static bool_t sx127x_set_state(uint8_t state)
{
    switch (state)
    {
    case RF_IDLE_STATE:
        return sx127x_enter_idle();

    case RF_SLEEP_STATE:
        return sx127x_enter_sleep();

    case RF_TX_STATE:
        return sx127x_enter_tx();

    case RF_RX_STATE:
        return sx127x_enter_rx();

    default:
        return FALSE;
    }
}


static bool_t sx127x_start_cca(uint8_t *val)
{
    switch (sx127x.modem)
    {
    case MODEM_FSK:     //*< CCA

        break;

    case MODEM_LORA:    //*< CAD
        cad_done = FALSE;
        cad_detected = FALSE;

        sx127x_write_reg( REG_LR_IRQFLAGSMASK, RFLR_IRQFLAGS_RXTIMEOUT |
                          RFLR_IRQFLAGS_RXDONE |
                          RFLR_IRQFLAGS_PAYLOADCRCERROR |
                          RFLR_IRQFLAGS_VALIDHEADER |
                          RFLR_IRQFLAGS_TXDONE |
                          RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL
                        );
        // DIO3=CADDone
        sx127x_write_reg( REG_DIOMAPPING1, (sx127x_read_reg( REG_DIOMAPPING1 )
                                            & RFLR_DIOMAPPING1_DIO0_MASK ) |
                          RFLR_DIOMAPPING1_DIO0_00 );

        sx127x.state = RF_CCA_STATE;
        sx127x_set_op_mode(RFLR_OPMODE_CAD);

        WHILE(!cad_done, 800, FALSE);  //*< 等待CAD中断,1个time对应16个ticks=2us

        *val = cad_detected ? FALSE : TRUE;
        break;

    default:
        break;
    }

    return TRUE;
}


static bool_t sx127x_init(void)
{
    sx127x_reset();

    sx127x_spi_init();
    rx_chain_calibration();

    sx127x_set_op_mode(RF_OPMODE_SLEEP);
    sx127x.state = RF_SLEEP_STATE;

    //*< DIO irq
    sx127x_dio_irq_init();

//    for (uint8_t i = 0; i < sizeof(radio_regs_init) / sizeof(radio_regs_t); i++)
//    {
//        sx127x_set_modem(radio_regs_init[i].modem);
//        sx127x_write_reg(radio_regs_init[i].addr, radio_regs_init[i].value);
//    }

    sx127x.modem = MODEM_FSK;
#if NODE_TYPE == NODE_TYPE_TAG
    sx127x.lora.rx_continuous = TRUE;
#else
    sx127x.lora.rx_continuous = TRUE;
#endif

    sx127x_set_modem( MODEM_LORA );

    sx127x_set_channel(basic_feq);
    sx127x_set_power(17);
    sx127x_write_reg(REG_LR_OCP, 0x0B); //*< ZM470 = 0x3F, Lora470=0x0b
    sx127x_write_reg(REG_LR_LNA, 0x23);
    sx127x_write_reg(REG_LR_TCXO, 0x09);
//    sx127x_write_reg(REG_LR_PADAC, 0x84);
    sx127x_set_config(9, 10, 1, 1);
    sx127x_set_preamble(6);
    sx127x_set_fix(0, 0);
    sx127x_set_hopping(0, 0);
    sx127x_set_iqinverted(FALSE);
    sx127x_set_rxtimeout(0x3FF);
    sx127x_read_reg(REG_LR_IRQFLAGS);
    sx127x_dio_irq_enable();

    return TRUE;
}

rf_result_t sx127x_get_value(rf_cmd_t cmd, void *value)
{
    rf_result_t ret = RF_RESULT_OK;
    switch (cmd)
    {
    case RF_MODE:
        *(int8_t *)value = sx127x.modem;
        break;

    case RF_FREQ:
        *(uint32_t *)value = basic_feq;
        break;

    case RF_POWER:
        *(int8_t *)value = sx127x.lora.power;
        break;

    case RF_CHANNEL:
        *(uint8_t *)value = rf_channel_offset / CHANNEL_OFFSET;
        break;

    case RF_RXRSSI:
        *(int8_t *)value = sx127x_get_rssi();
        break;

    case RF_RXFIFO_CNT:
        sx127x.lora_packet.size = sx127x_read_reg( REG_LR_RXNBBYTES );
        *(uint8_t *)value = sx127x.lora_packet.size;
        break;

    case RF_CCA:
        sx127x_start_cca((uint8_t *)value);
        break;

    default:
        ret = RF_RESULT_NOT_SUPPORTED;
        break;
    }

    return ret;
}

rf_result_t sx127x_set_value(rf_cmd_t cmd, uint8_t value)
{
    rf_result_t ret = RF_RESULT_OK;

    switch (cmd)
    {
    case RF_MODE:
        sx127x_set_modem((radio_modem_t)value);
        break;

    case RX_CONTINUOUS:
        sx127x.lora.rx_continuous = value;
        break;

    case RF_LORA_CONT:
        if (value)
        {
            sx127x_write_reg(REG_SEQCONFIG1, RF_SEQCONFIG1_FROMTX_TORX);
            sx127x_write_reg(REG_LR_MODEMCONFIG2, RFLR_MODEMCONFIG2_TXCONTINUOUSMODE_ON);
        }
        else
        {
            sx127x_write_reg(REG_SEQCONFIG1, 0x02);
            sx127x_write_reg(REG_LR_MODEMCONFIG2, 0x77);
        }
        break;
    case RF_DATARATE:
        sx127x_set_datarate(value);
        break;

    case RF_POWER:
        sx127x_set_power(value);
        break;

    case RF_CHANNEL:
        rf_channel_offset = value * CHANNEL_OFFSET;                        //一个信道改成400K，防止跨频
        sx127x_set_channel(rf_channel_offset + basic_feq);
        break;

    case RF_RXFIFO_FLUSH:
        sx127x_set_state(RF_SLEEP_STATE);
        break;

    case RF_STATE:
        if (!sx127x_set_state(value))
        {
            ret = RF_RESULT_ERROR;
        }
        break;

    default:
        ret = RF_RESULT_NOT_SUPPORTED;
        break;
    }

    return ret;
}

static bool_t sx127x_int_cfg(rf_int_t state,
                             rf_int_reg_t int_cb,
                             uint8_t type)
{
    (type == INT_ENABLE) ? (sx127x_dio_irq_enable()) : (sx127x_dio_irq_disable());
    (type == INT_ENABLE) ? ((int_cb != NULL) ? (rf_int_reg[state] = int_cb) : (NULL)) : (NULL);
    return TRUE;
}


int8_t sx127x_prepare(uint8_t const *buffer, uint8_t size)
{
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        //@todo
        break;

    case MODEM_LORA:
        sx127x_set_iqinverted(sx127x.lora.iq_inverted);

        sx127x.lora_packet.size = size;
        sx127x_write_reg( REG_LR_PAYLOADLENGTH, size );

        // Full buffer used for Tx
        sx127x_write_reg( REG_LR_FIFOTXBASEADDR, 0x80 );
        sx127x_write_reg( REG_LR_FIFOADDRPTR, 0x80 );

        // FIFO operations can not take place in Sleep mode
        if ( ( sx127x_read_reg( REG_OPMODE ) & ~RF_OPMODE_MASK ) == RF_OPMODE_SLEEP )
        {
            sx127x_enter_idle();
            delay_ms(1);
        }
        // Write payload buffer
        sx127x_write_buffer(REG_LR_FIFO, (uint8_t *)buffer, size );
        break;

    default:
        break;
    }

    return size;
}

int8_t sx127x_transmit(uint8_t count)
{
    sx127x_enter_tx();
    return count;
}

int8_t sx127x_send(uint8_t const *p_data, uint8_t count)
{
    sx127x_prepare((uint8_t *)p_data, count);
    sx127x_enter_tx();
    return count;
}

int8_t sx127x_recv(uint8_t *p_data, uint8_t count)
{
    uint8_t offset = sx127x_read_reg(REG_LR_FIFORXCURRENTADDR);
    sx127x_write_reg(REG_LR_FIFOADDRPTR, offset);
    if (sx127x.lora_packet.size >= count)
    {
        sx127x_read_buffer(REG_LR_FIFO, p_data, count);
        return count;
    }
    else
    {
        sx127x_read_buffer(REG_LR_FIFO, p_data, sx127x.lora_packet.size);
        return sx127x.lora_packet.size;
    }
}

const struct radio_driver sx127x_driver =
{
    sx127x_init,

    sx127x_prepare,
    sx127x_transmit,

    sx127x_send,
    sx127x_recv,

    sx127x_get_value,
    sx127x_set_value,

    sx127x_int_cfg,
};

void sx127x_dio0_irq(uint16_t time)
{
    volatile uint8_t irq_flags = 0;
    irq_flags = sx127x_read_reg( REG_LR_IRQFLAGS );

    if(((irq_flags & RFLR_IRQFLAGS_RXDONE_MASK) == RFLR_IRQFLAGS_RXDONE)
        && ((irq_flags & RFLR_IRQFLAGS_TXDONE_MASK) == RFLR_IRQFLAGS_TXDONE))
    {
        sx127x_write_reg( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXDONE );
    }

    if((irq_flags & RFLR_IRQFLAGS_RXDONE_MASK) == RFLR_IRQFLAGS_RXDONE)
    {
        switch (sx127x.modem)
        {
        case MODEM_FSK:
            //@todo add code
            break;

        case MODEM_LORA:
        {
            sx127x_write_reg( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_RXDONE );
            if (sx127x.lora.crc_on)
            {
                if ( ( irq_flags & RFLR_IRQFLAGS_PAYLOADCRCERROR_MASK ) == RFLR_IRQFLAGS_PAYLOADCRCERROR )
                {
                    // Clear Irq
                    sx127x_write_reg( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_PAYLOADCRCERROR );

                    if ( sx127x.lora.rx_continuous == FALSE )
                    {
                        sx127x.state = RF_IDLE_STATE;
                    }
                    //@todo add code stop rxtimeout timer

                    //@TODO add crc call back
                    if (rf_int_reg[RX_OVR_INT] != NULL)
                    {
                        ( *(rf_int_reg[RX_OVR_INT]) )(time);
                    }
                    return;
                }
            }

            if ( sx127x.lora.rx_continuous == FALSE )
            {
                sx127x.state = RF_RXOK_STATE;
            }
//            TimerStop( &RxTimeoutTimer );
            if (rf_int_reg[RX_OK_INT] != NULL)
            {
                ( *(rf_int_reg[RX_OK_INT]) )(time);
            }
        }
        break;

        default:
            break;
        }
    }
    else if((irq_flags & RFLR_IRQFLAGS_TXDONE_MASK) == RFLR_IRQFLAGS_TXDONE)
    {
        //@todo cannel txtimeout timer

        //@note clear txok
        if (sx127x.modem == MODEM_LORA)
        {
            op_mode_prev = RFLR_OPMODE_STANDBY;
            sx127x.state = RF_IDLE_STATE;
            sx127x_write_reg( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_TXDONE );
        }
        //@note: TX OK CALL back
        sx127x.state = RF_TXOK_STATE;
        if (rf_int_reg[TX_OK_INT] != NULL)
        {
            ( *(rf_int_reg[TX_OK_INT]) )(0);
        }
    }
}


void sx127x_dio1_irq(uint16_t time)
{
    switch (sx127x.state)
    {
    case RF_RX_STATE:
        switch (sx127x.modem)
        {
        case MODEM_FSK:
            //*< @todo
            //
            break;

        case MODEM_LORA:
            //*< @todo rx timeout call back
            sx127x_read_reg( REG_OPMODE );
            op_mode_prev = RFLR_OPMODE_STANDBY;
            sx127x.state = RF_IDLE_STATE;
            break;

        default:
            break;
        }
        break;

    case RF_TX_STATE:
        switch (sx127x.modem)
        {
        case MODEM_FSK:
            //*< @todo
            //
            break;

        case MODEM_LORA:
            break;

        default:
            break;
        }
        break;

    default:
        break;
    }
}


void sx127x_dio2_irq(uint16_t time)
{
    switch (sx127x.state)
    {
    case RF_RX_STATE:
        switch (sx127x.modem)
        {
        case MODEM_FSK:
            //*< @todo
            //
            break;

        case MODEM_LORA:
            if ( sx127x.lora.freq_hop_on == TRUE )
            {
                // Clear Irq
                sx127x_write_reg( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);
                uint8_t fhss_change_channel =
                    sx127x_read_reg( REG_LR_HOPCHANNEL ) & RFLR_HOPCHANNEL_CHANNEL_MASK;
                //*< @note rx fhss channel change call back
                //
            }
            break;

        default:
            break;
        }
        break;

    case RF_TX_STATE:
        switch (sx127x.modem)
        {
        case MODEM_FSK:
            //*< @todo
            //
            break;

        case MODEM_LORA:
            if ( sx127x.lora.freq_hop_on == TRUE )
            {
                // Clear Irq
                sx127x_write_reg( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_FHSSCHANGEDCHANNEL);
                uint8_t fhss_change_channel =
                    sx127x_read_reg( REG_LR_HOPCHANNEL ) & RFLR_HOPCHANNEL_CHANNEL_MASK;
                //*< @note tx fhss channel change call back
                //
            }
            break;

        default:
            break;
        }
        break;

    default:
        break;
    }
}


void sx127x_dio3_irq(uint16_t time)
{
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        //*< @todo
        //
        break;

    case MODEM_LORA:
        cad_done = TRUE;
        if ( ( sx127x_read_reg( REG_LR_IRQFLAGS ) & RFLR_IRQFLAGS_CADDETECTED ) == RFLR_IRQFLAGS_CADDETECTED )
        {
            sx127x_write_reg( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_CADDETECTED | RFLR_IRQFLAGS_CADDONE );
            //*< @note CAD done call back TRUE
            cad_detected = TRUE;
        }
        else
        {
            sx127x_write_reg( REG_LR_IRQFLAGS, RFLR_IRQFLAGS_CADDONE );
            //*< @note CAD done call back FASLE
            cad_detected = FALSE;
        }
        break;

    default:
        break;
    }
}

void sx127x_dio4_irq(uint16_t time)
{
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        //*< @todo cad detect call back
        //
        break;

    case MODEM_LORA:

        break;

    default:
        break;
    }
}

void sx127x_dio5_irq(uint16_t time)
{
    switch (sx127x.modem)
    {
    case MODEM_FSK:
        //*< @todo cad detect call back
        //
        break;

    case MODEM_LORA:

        break;

    default:
        break;
    }
}
//static uint8_t irq_flag;
//
//void sx127x_int_handler(uint16_t time)
//{
//    irq_flag = sx127x_read_reg(REG_LR_IRQFLAGS);
//}